<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module reliable</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module reliable</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Reliable is an OTP application that offers a solution to the problem of
  ensuring a sequence of Riak KV operations are guaranteed to occur, and to
  occur in order.


<h2><a name="description">Description</a></h2>Reliable is an OTP application that offers a solution to the problem of
  ensuring a sequence of Riak KV operations are guaranteed to occur, and to
  occur in order.
  The problem arises when one wants to write multiple associated objects to
  Riak KV which does not support multi-key atomicity, including but not
  exclusively, the update of application managed secondary indices after a
  write.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-opts">opts()</a></h3>
<p><tt>opts() = #{partition_key =&gt; binary()}</tt></p>


<h3 class="typedecl"><a name="type-scheduled_item">scheduled_item()</a></h3>
<p><tt>scheduled_item() = <a href="reliable_worker.html#type-work_item">reliable_worker:work_item()</a> | fun(() -&gt; <a href="reliable_worker.html#type-work_item">reliable_worker:work_item()</a>)</tt></p>


<h3 class="typedecl"><a name="type-work_id">work_id()</a></h3>
<p><tt>work_id() = <a href="reliable_worker.html#type-work_id">reliable_worker:work_id()</a></tt></p>


<h3 class="typedecl"><a name="type-work_item">work_item()</a></h3>
<p><tt>work_item() = [{<a href="reliable_worker.html#type-work_item_id">reliable_worker:work_item_id()</a>, <a href="reliable_worker.html#type-work_item">reliable_worker:work_item()</a>}]</tt></p>


<h3 class="typedecl"><a name="type-workflow_item">workflow_item()</a></h3>
<p><tt>workflow_item() = {Id::<a href="#type-workflow_item_id">workflow_item_id()</a>, {update | delete, <a href="#type-scheduled_item">scheduled_item()</a>}}</tt></p>


<h3 class="typedecl"><a name="type-workflow_item_id">workflow_item_id()</a></h3>
<p><tt>workflow_item_id() = term()</tt></p>


<h3 class="typedecl"><a name="type-workflow_opts">workflow_opts()</a></h3>
<p><tt>workflow_opts() = #{partition_key =&gt; binary(), on_terminate =&gt; fun((Reason::any()) -&gt; any())}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#abort-1">abort/1</a></td><td>When called within the functional object in <a href="#workflow-2"><code>workflow/2</code></a>,
makes the workflow silently return the tuple {aborted, Reason} as the
error reason.</td></tr>
<tr><td valign="top"><a href="#add_workflow_items-1">add_workflow_items/1</a></td><td>Adds a workflow item to the workflow stack.</td></tr>
<tr><td valign="top"><a href="#add_workflow_precedence-2">add_workflow_precedence/2</a></td><td>Relates on or more workflow items in a precedence relationship.</td></tr>
<tr><td valign="top"><a href="#enqueue-2">enqueue/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#enqueue-3">enqueue/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#ensure_in_workflow-0">ensure_in_workflow/0</a></td><td>Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</td></tr>
<tr><td valign="top"><a href="#find_workflow_item-1">find_workflow_item/1</a></td><td>
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</td></tr>
<tr><td valign="top"><a href="#get_workflow_item-1">get_workflow_item/1</a></td><td>Returns a workflow item that was previously added to the workflow stack
  with the <a href="#add_workflow_item-2"><code>add_workflow_item/2</code></a> function.</td></tr>
<tr><td valign="top"><a href="#is_in_workflow-0">is_in_workflow/0</a></td><td>Returns true if the process has a workflow context.</td></tr>
<tr><td valign="top"><a href="#is_nested_workflow-0">is_nested_workflow/0</a></td><td>Returns true if the current workflow is nested i.e.</td></tr>
<tr><td valign="top"><a href="#workflow-1">workflow/1</a></td><td>Equivalent to calling <a href="#workflow-2"><code>workflow/2</code></a> with and empty map passed as
  the <code>Opts</code> argument.</td></tr>
<tr><td valign="top"><a href="#workflow-2">workflow/2</a></td><td>Executes the functional object <code>Fun</code> as a Reliable workflow, i.e.</td></tr>
<tr><td valign="top"><a href="#workflow_id-0">workflow_id/0</a></td><td>Returns the workflow identifier or undefined if there is no workflow
  initiated for the calling process.</td></tr>
<tr><td valign="top"><a href="#workflow_nesting_level-0">workflow_nesting_level/0</a></td><td>Returns the current worflow nesting level.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="abort-1">abort/1</a></h3>
<div class="spec">
<p><tt>abort(Reason::any()) -&gt; no_return()</tt><br></p>
</div><p><p>When called within the functional object in <a href="#workflow-2"><code>workflow/2</code></a>,
makes the workflow silently return the tuple {aborted, Reason} as the
error reason.</p>

  Termination of a Babel workflow means that an exception is thrown to an
  enclosing catch. Thus, the expression <code>catch babel:abort(foo)</code> does not
  terminate the workflow.</p>

<h3 class="function"><a name="add_workflow_items-1">add_workflow_items/1</a></h3>
<div class="spec">
<p><tt>add_workflow_items(L::[<a href="#type-workflow_item">workflow_item()</a>]) -&gt; ok | no_return()</tt><br></p>
</div><p>Adds a workflow item to the workflow stack.
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="add_workflow_precedence-2">add_workflow_precedence/2</a></h3>
<div class="spec">
<p><tt>add_workflow_precedence(As::<a href="#type-workflow_item_id">workflow_item_id()</a> | [<a href="#type-workflow_item_id">workflow_item_id()</a>], Bs::<a href="#type-workflow_item_id">workflow_item_id()</a> | [<a href="#type-workflow_item_id">workflow_item_id()</a>]) -&gt; ok | no_return()</tt><br></p>
</div><p>Relates on or more workflow items in a precedence relationship. This
  relationship is used by the <a href="#workflow-2"><code>workflow/2</code></a> function to determine the
  workflow execution order based on the resulting precedence graph topsort
  calculation.
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="enqueue-2">enqueue/2</a></h3>
<div class="spec">
<p><tt>enqueue(WorkId::<a href="#type-work_id">work_id()</a>, WorkItems::[<a href="#type-work_item">work_item()</a>]) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="enqueue-3">enqueue/3</a></h3>
<div class="spec">
<p><tt>enqueue(WorkId::<a href="#type-work_id">work_id()</a>, WorkItems::[<a href="#type-work_item">work_item()</a>], Opts::<a href="#type-opts">opts()</a>) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="ensure_in_workflow-0">ensure_in_workflow/0</a></h3>
<div class="spec">
<p><tt>ensure_in_workflow() -&gt; ok | no_return()</tt><br></p>
</div><p>Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="find_workflow_item-1">find_workflow_item/1</a></h3>
<div class="spec">
<p><tt>find_workflow_item(Id::<a href="#type-workflow_item_id">workflow_item_id()</a>) -&gt; {ok, <a href="#type-workflow_item">workflow_item()</a>} | error | no_return()</tt><br></p>
</div><p>
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="get_workflow_item-1">get_workflow_item/1</a></h3>
<div class="spec">
<p><tt>get_workflow_item(Id::<a href="#type-workflow_item_id">workflow_item_id()</a>) -&gt; <a href="#type-workflow_item">workflow_item()</a> | no_return() | no_return()</tt><br></p>
</div><p>Returns a workflow item that was previously added to the workflow stack
  with the <a href="#add_workflow_item-2"><code>add_workflow_item/2</code></a> function.
  Fails with a <code>badkey</code> exception if there is no workflow item identified by
  <code>Id</code>.
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="is_in_workflow-0">is_in_workflow/0</a></h3>
<div class="spec">
<p><tt>is_in_workflow() -&gt; boolean()</tt><br></p>
</div><p>Returns true if the process has a workflow context.
  See <a href="#workflow-2"><code>workflow/2</code></a>.</p>

<h3 class="function"><a name="is_nested_workflow-0">is_nested_workflow/0</a></h3>
<div class="spec">
<p><tt>is_nested_workflow() -&gt; boolean() | no_return()</tt><br></p>
</div><p>Returns true if the current workflow is nested i.e. has a parent
  workflow.
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="workflow-1">workflow/1</a></h3>
<div class="spec">
<p><tt>workflow(Fun::fun(() -&gt; any())) -&gt; {ok, {WorkId::binary(), ResultOfFun::any()}} | {error, Reason::any()} | no_return()</tt><br></p>
</div><p>Equivalent to calling <a href="#workflow-2"><code>workflow/2</code></a> with and empty map passed as
  the <code>Opts</code> argument.</p>

<h3 class="function"><a name="workflow-2">workflow/2</a></h3>
<div class="spec">
<p><tt>workflow(Fun::fun(() -&gt; any()), Opts::<a href="#type-opts">opts()</a>) -&gt; {ok, {WorkId::binary(), ResultOfFun::any()}} | {error, Reason::any()} | no_return()</tt><br></p>
</div><p><p>Executes the functional object <code>Fun</code> as a Reliable workflow, i.e.
ordering and scheduling all resulting Riak KV object writes and deletes.</p>

  <p>Any function that executes inside the workflow that wants to be able to
  schedule work to Riak KV, needs to use the infrastructure provided in this
  module to add workflow items to the workflow stack
  (see <a href="#add_workflow_items-1"><code>add_workflow_items/1</code></a>) and to add the precedence amongst them
  (see <a href="#add_workflow_precedence-2"><code>add_workflow_precedence/2</code></a>).</p>

  <p>Any other operation, including reading and writing from/to Riak KV by
directly using the Riak Client library will work as normal and
will not affect the workflow. Only by calling the special functions in this
module you can add work items to the workflow.</p>

  <p>If something goes wrong inside the workflow as a result of a user
  error or general exception, the entire workflow is terminated and the
  function raises an exception. In case of an internal error, the function
  returns the tuple <code>{error, Reason}</code>.</p>

  <p>If everything goes well, the function returns the tuple
  <code>{ok, {WorkId, ResultOfFun}}</code> where <code>WorkId</code> is the identifier for the
  workflow scheduled by Reliable and <code>ResultOfFun</code> is the value of the last
  expression in <code>Fun</code>.</p>

  <p>&gt; Notice that calling this function schedules the work to Reliable, you need
to use the WorkId to check with Reliable the status of the workflow
execution.</p>

  <p>The resulting workflow execution will schedule the writes and deletes in the
  order defined by the dependency graph constructed using
  <a href="#add_workflow_precedence-2"><code>add_workflow_precedence/2</code></a>.</p>

  <p>&gt; If you want to manually determine the execution order of the workflow you
  should use the <a href="#enqueue-2"><code>enqueue/2</code></a> function instead.</p>

  <p>The <code>Opts</code> argument offers the following options:</p>

  <p>* <code>on_terminate` – a functional object `fun((Reason :: any()) -&gt; ok)</code>. This
  function will be evaluated before the call terminates. In case of successful
  termination the value <code>normal</code> will be  passed as argument. Otherwise, in
  case of error, the error reason will be passed as argument. This allows you
  to perform a cleanup after the workflow execution e.g. returning a Riak
  connection object to a pool. Notice that this function might be called
  multiple times in the case of nested workflows. If you need to conditionally
  perform a cleanup operation within the functional object only at the end of
  the workflow call, you can use the function <code>is_nested_workflow/0</code>
to take a decision.</p>

  Calls to this function can be nested and the result is exactly the same as it
  would without a nested call i.e. nesting workflows does not provide any kind
  of stratification and thus there is no implicit precedence relationship
  between workflow items scheduled at different nesting levels, unless you
  explecitly create those relationships by using the
  <a href="#add_workflow_precedence-2"><code>add_workflow_precedence/2</code></a> function.</p>

<h3 class="function"><a name="workflow_id-0">workflow_id/0</a></h3>
<div class="spec">
<p><tt>workflow_id() -&gt; binary() | no_return()</tt><br></p>
</div><p>Returns the workflow identifier or undefined if there is no workflow
  initiated for the calling process.
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>

<h3 class="function"><a name="workflow_nesting_level-0">workflow_nesting_level/0</a></h3>
<div class="spec">
<p><tt>workflow_nesting_level() -&gt; pos_integer() | no_return()</tt><br></p>
</div><p>Returns the current worflow nesting level.
  Fails with a <code>no_workflow</code> exception if the calling process doe not
  have a workflow initiated.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
